# Redis单机

### 各个数据类型的应用

| 数据类型 | 应用                                                         |
| -------- | ------------------------------------------------------------ |
| String   | 统计计数（库存）；二进制存储(图片等)；是否有效/签到（BitMap） |
| Hash     | 存储对象                                                     |
| List     | 最新消息/评论队列                                            |
| Set      | 计算交集、并集、差集（共同好友）                             |
| ZSet     | 排行榜、带权重的消息队列                                     |

### **分布式锁的实现**

> **Redis 实现**：=> [很好的参考](https://juejin.im/post/5e61a454e51d4526f071e1df)
>
> 1. 获取锁的时候，使用 setnx （`SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]`）加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。
> 2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
> 3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。
> 4. **注意**：在集群模式下，主从复制是异步的。当客户端A持有主节点中资源的锁时，主节点瘫痪，从节点升级为主节点，此时客户端B可以获取到相同资源的锁，这会导致多个客户端同时持有相同资源的锁（要考虑自身业务是否允许），**安全性违规**！ => [read more](https://blog.csdn.net/qq_40322118/article/details/90669002)
>
> **ZooKeeper 实现**
>
> 1. 创建一个目录 mylock；
> 2. 线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；
> 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
> 4. 线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
> 5. 线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。
>
> **实现对比**
>
> ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。

### **Redis 的持久化方式**

- **RDB 快照（snapshot）**

  > 将存在于某一时刻的所有数据都写入到硬盘中。
  >
  > 原理： 在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。
  >
  > **当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:**
  >
  > - Redis 创建一个子进程。
  > - 子进程将数据集写入到一个临时快照文件中。
  > - 当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。
  >
  > 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。
  >
  > **快照的优点**
  >
  > - 它保存了某个时间点的数据集，非常适用于数据集的备份。
  > - 很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。
  > - 快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。
  > - 与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。
  >
  > **快照的缺点**
  >
  > - 如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。
  > - 快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。

- **AOF**

  > **AOF 的原理**
  >
  > - Redis 创建一个子进程。
  > - 子进程开始将新 AOF 文件的内容写入到临时文件。
  > - 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。
  > - 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。
  > - 搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。
  >
  > **AOF 的优点**
  >
  > - 使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。
  > - AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。
  > - Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。
  > - AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。
  >
  > **AOF 的缺点**
  >
  > - 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
  > - 根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。

### **Redis 过期策略**

> - **noeviction** - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错（默认策略）。
> - **allkeys-lru** - 在主键空间中，优先移除最近未使用的 key（推荐）。
> - **allkeys-random** - 在主键空间中，随机移除某个 key。
> - **volatile-lru** - 在设置了过期时间的键空间中，优先移除最近未使用的 key。
> - **volatile-random** - 在设置了过期时间的键空间中，随机移除某个 key。
> - **volatile-ttl** - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。

#### Redis的key删除策略

> 惰性删除+定期删除
>
> **惰性删除流程：**
>
> 在进行get或setnx等操作时，先检查key是否过期，若过期，删除key，然后执行相应操作；
>
> 若没过期，直接执行相应操作
>
> **定期删除流程**（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）
>
> 遍历每个数据库（就是redis.conf中配置的"database"数量，默认为16），检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体执行下边的操作）
>
> - 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历
> - 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key
> - 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。

## Redis事务



### Redis 快的原因

> 1. 绝大部分请求是纯粹的内存操作（非常快速）
> 2. 业务上（数据的读取）采用单线程,避免了不必要的上下文切换和竞争条件
> 3. 内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，提高了IO性能。

### Redis注意的性能问题

> - Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
> - 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
> - 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
> - 尽量避免在压力很大的主库上增加从库
> - 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-Slave3…

# Redis集群(V3.0+)

## 主从模式

#### **主从模式的特点**

>  主数据库（**一般一个集群中只有一个**）可以进行读写操作，当读写操作导致数据变化时会自动将数据增量同步给从数据库（**异步同步**）
>
>  一个master可以拥有多个slave，但是一个slave只能对应一个master，并且slave也可以有自己的slave，拥有slave的slave仍然是只读的（即：master A <= slave B <= slave C）
>
>  slave重新启动后会抛弃原有数据并与 master完成一次 **全量复制**
>
>  master挂了以后，**不会**在slave节点中重新选一个master
>
>  master挂了以后，**不影响slave的读，但Redis不再提供写服务**，master重启后redis将**重新对外提供写服务**
>
>  从数据库一般都是只读的。
>
>  Redis不支持主主复制，但支持从从复制。

#### **Redis主从复制原理**

> **全量复制（最高可能导致秒级停止对外服务）：**
>
> slave启动成功并建立与master的连接后会发送一个 SYNC 命令请求同步数据
>
> master 收到 SYNC 命令后执行 BGSAVE 命令生成RDB文件，同时使用缓冲区记录此后执行的所有写命令
>
> SYNC 命令执行完毕之后，master 先向 slave 发送RDB快照文件，发送期间继续记录被执行的写命令。RDB文件发送完成后再发送复制缓冲区记录的数据，slave 会将RDB和缓冲区数据存放到磁盘中
>
> slave 收到快照文件后清空原有数据，并将接收到的数据加载到内存中。此时开始接收命令请求，并执行来自master服务器缓冲区的写命令
>
> **增量复制：**
>
> master继续将新的所有收集到的修改命令依次传给slave，完成同步。


## 哨兵模式（Sentinel）

#### 哨兵模式的特点

> * sentinel模式是建立在主从模式的基础上，一般情况下数据节点（master/slave）应>=2，哨兵节点应>=3（通常哨兵的部署数量为单数）
> * 当master挂了以后，sentinel会在slave中选择一个做为master，修改自身配置文件sentinel.conf（自身升级为master）并通知所有slave修改配置文件（比如slaveof属性会指向新的master）
> * 当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据
> * 多sentinel配置的时候，sentinel之间也会互相监控。sentinel之间会通过发布/订阅的形式同步集群各个节点的状态
> * sentinel通过**修改各节点配置文件**的方式控制节点的主从关系 / 同步密码配置等
> * 一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis
> * 在运行Sentinel时必须使用配置文件，因为系统将使用此文件来保存当前节点状态。Sentinel默认使用**26379**端口
> * 哨兵也是一台Redis服务器，只是不提供数据服务
> * 应将三个Sentinel实例放置到被认为以独立方式发生故障的计算机或虚拟机中。

#### 哨兵节点的作用

> **监控**：Sentinel会不断检查您的主实例和副本实例是否按预期工作
>
> 哨兵节点使用ping指令（每秒一次）判断节点（其他哨兵节点/master/slave）是否可用，哨兵与master/slave之间通过info指令（每 10 秒一次）获取节点详细信息，哨兵之间会通过发布/订阅模式同步每次的节点检查结果。如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线。
>
> **通知**：Sentinel可以通过API通知其他节点（哨兵间、客户端），其中一个受监视的Redis实例出了问题
>
> **自动故障转移**：如果主服务器未按预期工作，则Sentinel可以选取一个slave作为master，并将其他slave节点重新配置为使用新的master，在新的客户端连接Redis时会通知其通知使用新地址。
>
> 自动故障转移详述：某一个sentinel节点监控到故障数据节点N（master/slave）时，会将故障节点信息同步到sentinel集群网络中，将节点N的状态标记为SRI_S_DOWN（主观下线）。sentinel集群中的其他sentinel节点收到故障信息后，会去检查对应节点N是否真的故障（每秒一次），当超过一定数量（取决于具体配置）sentinel节点认为节点N故障时，会将节点N的状态标记为SRI_O_DOWN（客观下线）。sentinel集群内部会投票选举出一个sentinel节点处理故障问题，sentinel从slave中选出（选择标准：在线的、响应速度快的、与原master断开时间间隔较短的、优先原则）一个节点当master，并通知所有slave节点切换到新的master（修改自身配置文件）
>
> **配置提供**：Sentinel充当客户端服务发现的授权来源：**客户端连接到Sentinels**，以询问负责给定服务的当前Redis主服务器的地址。 如果发生故障转移，Sentinels将报告新地址。

## Cluster模式

#### 集群模式官方文档摘要

> - **<u>每个 Redis 群集节点都需要打开两个 TCP 连接</u>**（否则不能正常工作）。一个端口用于为客户端提供服务（默认6379），第二个*高*端口用于群集总线，即使用二进制协议的节点间通信通道（数据端口+固定偏移量10000获得的端口，例如：16379 <=6379+10000）。
>
> - 为了使 Docker 与 Redis 群集兼容，您需要使用 Docker 的**主机网络模式** （`--net=host`）。
>
> - Redis 群集不使用一致性哈希，而是使用**哈希槽**的概念。Redis 群集中有 **16384** 个哈希插槽，要计算给定key所在的哈希槽，我们只需对key的CRC16 取模 16384。
>
> - 当Redis集群新增节点时，只需要将一些哈希槽从原有的节点移动到新节点。删除节点时，也只需要将原有节点的哈希槽移动到其他节点，就可以将其从集群中完全删除。由于哈希槽移动不需要停止任何操作，因此集群**增删节点不需要任何停机时间**。
>
> - 为了保证集群可用性，Redis使用主从模型，每个哈希槽有1（主节点本身）到N个副本（N-1个从节点+1个主节点），当主节点故障时，集群自动将从节点<u>通过选举算法(Paxos、Raft)</u>升级为主节点，并继续提供服务（注意：如果主节点和从节点同时故障，该段哈希槽仍会停止服务）。
>
> - Redis Cluster无法保证强一致性。 第一个原因是因为它使用异步复制。 这意味着在写入期间发生以下情况：当写入数据到主节点B时，主节点写入数据并响应一个`OK`，然后将写操作传播到其从节点B1，B2和B3。就是说Redis只能保证主节点数据写入成功，对从节点的数据不做任何保证，这就会导致数据主从不一致的问题。可以通过开启`同步复制`的方式保证一致性，但这会导致性能降低（<u>仍不保证绝对的强一致性</u>）。在客户端与少数实例（至少包括主实例）隔离的网络分区中，Redis还有一定肯会丢失写操作。
>
> - Redis最小群集要求至少包含三个主节点。建议启动一个包含三个主节点和三个从节点的群集。

#### Cluster模式的特点

> 1. 所有的节点都是一主N从的模式（N>=1），**从节点不提供服务**，仅作为备用
> 2. 不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上，  并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为
> 3. 所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。
> 4. 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。
> 5. 客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，**连接集群中任何一个可用节点即可**。
> 6. 与主从模式/Sentinel模式不同的是，**Cluster模式的任一节点都不再包含全量数据**，数据会分散存储在各个节点。redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。
> 7. Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。

