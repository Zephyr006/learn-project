

# MySQL组合索引

>  假设表 t 工包含4列，分别为A、B、C、D，其中A是主键，B、C 、D构成组合索引
>
> ```alter table tt add index idx_composition (`B`, `C`, `D`);```

- 组合索引中是否生效与组合索引中列在where子句中出现的顺序无关，与出现了哪些列有关。如：`select * from table_name where C='' and B='' and D='';` 等价于 `select * from table_name where B='' and C='' and D='';`
- 存储引擎不能使用索引**范围条件**右边的列，例如：`select * from table_name where B='' and C > '' and D='';` 中，B用到了，C也用到了，D没有用到，这个地方C是范围值，也算断点，只不过自身用到了索引
- 在MySQL5.7中，`is nul`l 可以使用索引，而 `is not null` 可以使用索引（实践得出的结论，与其他文章中的描述不同），并且 `is not null` 会阻断后续列使用索引。例如： `select id from table_name where C is not null and B is null and D is null;` 中，B使用了索引，D和C没有用到索引。而 `select id from table_name where C is null and B is null and D is null;` 可以使用组合索引中的三个列。
- 在where子句中使用like会使组合索引中的当前列及其右侧的索引失效。例如：`select * from table_name where B='' and D='' and C like '123%';` 查询中，B使用了索引，C和D都没有使用索引。

# MySQL聚簇索引

### MySQL聚簇索引的数据结构（B+树）

InnoDB的聚簇索引使用**B+树**存储索引和数据，其中索引根据主键（或唯一索引，或生成的GEN_CLUST_INDEX列，见#InnoDB表上的MySQL聚集索引）有序的存储在非叶子节点中（每个非叶子节点保存在一个数据页中，MySQL默认的**非压缩数据页为16KB**），数据则保存在叶子节点中。

聚簇索引的叶子节点就是数据节点

非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针

### 聚簇索引的概念

以下内容来自 [MySQL聚簇索引官方文档](https://www.mysqltutorial.org/mysql-index/mysql-clustered-index/)

通常，索引是一个独立的数据结构，例如B-Tree，索引的存储是用于更快查找的键值。另一方面，*聚集索引实际上是表， 它实际上是一种强制对表的行进行排序的索引*。一般来说，DBMS都会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础。

聚簇索引创建完成后，表中的所有行都将根据创建聚簇索引的关键列进行存储（注：也就是说，表中的所有数据都是按照索引列进行有序存储的）。因为聚集索引按排序顺序存储行，所以**每个表只有一个聚集索引**。

### InnoDB表上的MySQL聚集索引

以下内容来自 [MySQL聚簇索引官方文档](https://www.mysqltutorial.org/mysql-index/mysql-clustered-index/)

每个InnoDB的表都要求有一个聚簇索引，聚簇索引帮助InnoDB表优化增删改查的数据操作。聚簇索引的创建逻辑如下：

- 当您为InnoDB表定义主键时，MySQL使用主键作为聚簇索引。

- 如果您没有表的主键，则MySQL将搜索第一个UNIQUE索引，其中所有键列都不为NULL，并将该UNIQUE索引用作聚集索引。

- 如果InnoDB表没有主键或合适的唯一索引（注：合适的唯一索引，指构成该唯一索引的所有列都不为NULL），则MySQL会（在包含行ID值的合成列上）生成一个名为GEN_CLUST_INDEX的隐藏的聚集索引。

**每个InnoDB表始终有且只有一个聚集索引**。

除聚簇索引外，所有其他索引均为非聚簇索引或辅助索引。 在InnoDB的表中，**辅助索引中的每个记录均包含该行的主键列以及非聚集索引中指定的列**。 MySQL将这个主键值用于聚集索引中的行查找。因此，主键应该尽量短一点，否则辅助索引将使用更多的空间。 通常，主键列推荐使用自增整数。

### 聚簇索引的特点

- （优）查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高。
- （优）对于范围查询的效率很高，因为其数据是按照大小排列的。（磁盘顺序读取）
- （缺）索引的更新代价高：数据更新，为了保持聚簇索引的有序，需要将数据移动到相应的位置，而且可能导致页分裂（页已满）。
- （缺）插入的速度严重依赖插入的顺序，如果是无序的主键（如UUID），则会明显降低插入速度

## 索引的用处
1. 使用索引快速查找匹配where子句的行
2. 从consideration中消除行，如果可以在多个索引中选择，MySQL通常会使用找到最少行的索引
3. 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行
4. 当有表连接（join）的时候，从其他表检索行数据
5. 查找特定索引列的min或max值（因为索引的数据是有序的）
6. 如果排序或分组是在可用索引的最左前缀上完成的，则使用索引对表进行排序和分组
7. 在某些情况下，可以优化查询以检索值，而无需查询数据行（即：把要查询的数据放在索引中）

### B-Tree索引的限制

- 如果不是按照索引的最左列开始查找，则无法使用索引（索引的最左匹配原则）
- **在组合索引中，不能跳过索引中的列。**例如，索引index(A,B,C)，如果在where子句中只指定A和C的查询条件，而没有出现B的查询条件，则MySQL只能使用索引的第一列（出自高性能MySQL）
- 如果where子句中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找范围。例如：`where A='a' and B like 'abc*' and C='c'`（建议使用多个等于条件来代替范围条件）

# 名词解释

### 回表

回表是什么意思？就是你执行一条sql语句，需要从两个b+索引中去取数据。举个例子，表table有a,b,c三个字段，其中id是主键，name上建了索引：

- `SELECT * FROM tbl WHERE id=1`这样不会产生回表，因为所有的数据在id的索引树中均能找到。
- `SELECT * FROM tbl WHERE name=1`这样就会产生回表，因为where条件是name字段，那么会去name的索引树里查找数据，但name的索引里面只有主键id和辅助索引name两个字段的值，没有c，那么这个查询为了取到c字段，就要取出主键id的值，然后去id的索引树去找c字段的数据，查了两个索引树，这就叫回表。

怎么避免？不是必须的字段就不要出现在SELECT里面。或者name,c建联合索引，或者使用主键进行select操作。但具体情况要具体分析，索引字段多了，存储和插入数据时的消耗会更大。这是个平衡问题。

![img](../../assets/images\主索引（聚簇索引）和普通索引之间的关系.png)

### 索引覆盖（Extra：Using index）

索引覆盖就是查当前索引能查到所需要的所有数据，而不需要去另外的数据结构（通常是主键索引）去查。其实就是不用回表。

不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，而哈希索引、全文索引和空间索引都不存储索引列的值，所以**MySQL只能使用B-Tree索引做覆盖索引**。

### 最左匹配原则

在组合索引中，MySQL会从索引中最左边出现的列开始匹配，并一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，**where子句中的索引可以是任意顺序**，mysql的查询优化器会帮你优化成索引可以识别的形式。

> 帮助理解：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

### 索引下推（Extra：Using index condition）

索引下推（index condition pushdown ）简称ICP。指在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎（在MySQL5.6之前，存储引擎的API设计不允许将查询过滤条件传到存储引擎层），然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。相反的，在不使用ICP的情况下，在使用辅助索引进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器判断数据是否符合条件 。

索引下推在非主键索引上的优化，可以有效减少回表的次数。

### 冗余索引

如果创建了索引 `idx(A,B)` ，在创建索引 `idx(A)` 就是冗余索引，因为这只是前一个索引的前缀索引。根据最左匹配原则，索引 `idx(A,B)` 也可以当做索引 `idx(A)` 来使用（这种冗余只是对B-Tree索引来说的）。如果再创建索引 `idx(B,A)` ，则不是冗余索引，索引 `idx(B)`  也不是冗余索引，因为B不是索引 `idx(A,B)` 的最左前缀列。另外，其他不同类型的索引（如哈希索引或全文索引）也不是B-Tree索引的冗余索引，而无论覆盖的索引的列是什么。

大多数情况下都不需要冗余索引，应该尽量扩展现有索引而不是创建新的索引。但有时出于性能考虑也会需要冗余索引，因为扩展已有的索引可能会导致其变得太大而影响其他查询的性能。表中的索引过多会增加索引的维护成本而导致插入速度变慢。

# 哈希索引

哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。在MySQL中，**只有Memory引擎显式支持哈希索引**，这也是Memory引擎的默认索引类型。Memory引擎同时也支持B-Tree索引。

##### **创建自定义哈希索引以提高性能**

思路：在B-Tree的基础上创建一个伪哈希索引，该索引列的值可以是一个较长的列的哈希结果值（如CRC32，不要使用SHA或MD5，因为函数计算出来的哈希值是非常长的字符串，可以使用MD5函数返回值的一部分作为自定义哈希函数）。这样实现的缺陷是要维护哈希值，可以手动维护，也可以使用触发器实现。

例子：表中的某个列为url值，正常情况下有如下查询：`select id from url where url='www.baidu.com';`，若删除原来url列上的索引，而新增一个被索引的url_crc列，使用CRC32做哈希，就可以使用下面的查询条件：`select id from url where url='www.baidu.com' and url_crc=CRC32("www.baidu.com");`，使用哈希函数进行查询时，必须在where子句中包含常量值，即查询条件`url='www.baidu.com'`）。

# 其他补充

- InnoDB在辅助索引上使用共享（读）锁，但访问主键索引需要排他（写）锁，这消除了使用覆盖索引的可能性。
- InnoDB存储引擎使用页作为最小数据读取单位，同一数据页中的数据会被一次性读取出来。InnoDB默认page大小是**16KB**。

- order by子句需要满足索引的最左前缀匹配的要求，否则MySQL无法利用索引排序
- 只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方式都一样（正序或倒序），MySQL才能够使用索引来对结果做排序
- 如果查询要关联多张表，则只有当order by子句引用的字段全部为第一张表时，才能使用索引做排序。