### ReentrantLock
通用的高性能可重入锁实现

## ReentrantReadWriteLock

### StampedLock

Jdk在1.8提供的一种读写锁,，相比较ReentrantReadWriteLock性能更好，因为ReentrantReadWriteLock在读写之间是互斥的，使用的是一种悲观策略，在读线程特别多的情况下，会造成写线程处于饥饿状态，虽然可以在初始化的时候设置为true指定为公平，但是吞吐量又下去了.而StampedLock是提供了一种乐观策略，更好的实现读写分离，并且吞吐量不会下降。

##### Apis
- writeLock：阻塞式的获取一个独占写锁，，当一个线程获得该锁后，其他请求读锁或者写锁的线程阻塞， 获取成功后，会返回一个stamp（凭据）变量来表示该锁的版本，在释放锁时调用unlockWrite方法传递stamp参数。提供了非阻塞式获取写锁`tryWriteLock`。
- readLock：获取一个共享的悲观读锁，在没有线程获取写锁情况下，多个线程可以获取该锁。如果有写锁获取，那么其他线程请求读锁会被阻塞。悲观读锁会认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据进行加锁，这是在读少写多的情况下考虑的。请求该锁成功后会返回一个stamp值，在释放锁时调用unlockRead方法传递stamp参数。提供了非阻塞式获取锁方法tryReadLock。
- tryOptimisticRead：相对比悲观读锁，在操作数据前并没有通过CAS设置锁的状态，如果没有线程获取写锁，则返回一个非0的stamp变量，获取该stamp后在操作数据前还需要调用validate方法来判断期间是否有线程获取了写锁，如果是返回值为0则有线程获取写锁，如果不是0则可以使用stamp变量的锁来操作数据。由于tryOptimisticRead并没有修改锁状态，所以不需要释放锁。这是读多写少的情况下考虑的，不涉及CAS操作，所以效率较高，在保证数据一致性上需要复制一份要操作的变量到方法栈中，并且在操作数据时可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性得到了保证。

